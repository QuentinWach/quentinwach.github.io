<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Dubins Paths for Waveguide Routing | Q. Wach</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Dubins Paths for Waveguide Routing" />
<meta name="author" content="Quentin Wach" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="What does the perfect waveguide routing look like? Dubins paths, already well known in robotics and control theory, turn out to be a simple and highly practical solution. This post notes a few useful recources and explains what the advantages of Dubins paths are compared to other waveguide interconnects that are often used." />
<meta property="og:description" content="What does the perfect waveguide routing look like? Dubins paths, already well known in robotics and control theory, turn out to be a simple and highly practical solution. This post notes a few useful recources and explains what the advantages of Dubins paths are compared to other waveguide interconnects that are often used." />
<link rel="canonical" href="http://localhost:4000/science-engineering/2024/02/15/dubins-paths-for-waveguide-routing.html" />
<meta property="og:url" content="http://localhost:4000/science-engineering/2024/02/15/dubins-paths-for-waveguide-routing.html" />
<meta property="og:site_name" content="Q. Wach" />
<meta property="og:image" content="http://localhost:4000/images/dubin/wikipedia_4.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-15T20:38:24+01:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="http://localhost:4000/images/dubin/wikipedia_4.png" />
<meta property="twitter:title" content="Dubins Paths for Waveguide Routing" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Quentin Wach"},"dateModified":"2024-02-15T20:38:24+01:00","datePublished":"2024-02-15T20:38:24+01:00","description":"What does the perfect waveguide routing look like? Dubins paths, already well known in robotics and control theory, turn out to be a simple and highly practical solution. This post notes a few useful recources and explains what the advantages of Dubins paths are compared to other waveguide interconnects that are often used.","headline":"Dubins Paths for Waveguide Routing","image":"http://localhost:4000/images/dubin/wikipedia_4.png","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/science-engineering/2024/02/15/dubins-paths-for-waveguide-routing.html"},"url":"http://localhost:4000/science-engineering/2024/02/15/dubins-paths-for-waveguide-routing.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">

  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png" ><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Q. Wach" /><script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script>
</head>

</head><body onload="document.body.style.opacity='1'"><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Q. Wach</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About</a><a class="page-link" href="/science_and_engineering">Science &amp; Engineering</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div style="height: 50px;">
          </br>
        </div>
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Dubins Paths for Waveguide Routing</h1><p class="post-meta">by 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Quentin Wach</span></span>
      
      
        • 
        17
       min read for 
        3079
       words •
      <time class="dt-published" datetime="2024-02-15T20:38:24+01:00" itemprop="datePublished">
        Feb 15, 2024
      </time></p>
  </header>

  <div>
    <div class="post-content e-content" itemprop="articleBody">
      <!--Read the <a href="/pdfs/Dubins Paths for Waveguide Routing - Quentin Wach - 2023.pdf"><button class="PDFButton">PDF</button></a>.-->
<p><span class="sidenote-left">
<em>(Updated: March 12, 2024.)</em> I deleted the majority of the code I presented when I posted this first as it was quite hacky and all the recources can be found in the links below. It should also be added that, while much of the photonics community does not seem to be aware of Dubins paths and instead talk about s-bends and so on, I believe libraries already implement similar methods and Dubins paths are more or less just a generalization that can make life easier at times. It sure did for me and my work.
</span></p>

<p><em>What does the perfect waveguide routing look like? Traditional waveguide interconnects lack efficiency and optimization, leading to suboptimal photonic integrated circuits (PICs). Addressing key concerns like minimizing internal and radiation losses, reducing cross-talk, and avoiding unnecessary crossings, I explored the concept of finding the shortest path between two points in a PIC given a minimum bending radius. Dubins paths, already well known in robotics and control theory, emerged as a simple and highly practical solution.</em></p>

<div class="tag_list"> 
    <div class="tag">photonic integrated circuits</div>
    <div class="tag">design automation</div>
    <div class="tag">robotics</div>
    <div class="tag">gds</div>
</div>

<h3 id="1-introduction">1 Introduction</h3>
<p>I’ll try to keep this short and not ramble too much. I just want to get this out there since I found it rather useful and can’t believe it isn’t yet standard.</p>

<p>When I started my work on layouts for photonic integrated circuit in September 2023, it became quickly obvious that the typical waveguide interconnects provided by libraries are not well behaved nor optimal as to improve the performance and compactness of the photonic integrated circuit. Most commonly, we have simple straights, circular arcs, all sorts of splines, as well as Euler-bends, in short: They are all simple analytical functions or splines that (try to) optimize themselves. All of these are either simple building blocks that leave most of the work to the designer who has to plan out and specify every route, or behave extremely poorly and lead to overly bendy results that may even cross each other.</p>

<p>So in my first two weeks there, I was thinking about what we have to consider. Waveguides have to fullfil multiple criteria. They need to be…</p>

<ul>
  <li>As short as possible as to minimize internal losses.</li>
  <li>As straight and continuos as possible as to minimize radiation losses.</li>
  <li>As far away from other waveguides and structures as to minimize cross-talk.</li>
  <li>Does not cross other waveguides unless close to a 90° angle if absolutely necessary.</li>
</ul>

<p>It became quickly obvious that trying to find an optimum for all these design parameters is impossible unless we either weigh their importance using a complicated metric we have to justify, or make much harder constraints. Since it is common to have a fixed minimum bending radius for waveguides, it makes sense to translate this here. I then boiled all of the considerations down to the single, I believe, most important question: <strong>“What is the shortest path between the pin or vector \(\vec{a}\) and pin or vector \(\vec{b}\) given a minimum bending radius?”</strong></p>

<p>As it turns out, the answer is rather simple and long established in the field of robotics / control theory. <strong>Dubins paths!</strong></p>

<h3 id="2-what-are-they">2 What are they?</h3>
<p>Dubins paths are named after Lester Dubins, who introduced them in the 1950s<sup id="fnref:DubinPaper" role="doc-noteref"><a href="#fn:DubinPaper" class="footnote" rel="footnote">1</a></sup>. They refer to the shortest paths that a vehicle can take from one point to another while constrained to move at a specific minimum turning radius. These paths are thus commonly studied in the field of motion planning for vehicles, particularly in robotics and aerospace engineering.</p>

<style>
    img[alt=dubin1] { float: right; width: 65%; padding: 10px; }
</style>

<p><img src="/images/dubin/wikipedia_3.png" alt="dubin1" /></p>

<p>These paths simply connect circular arcs with straights which leaves us with a couple of characteristic Dubins paths:</p>
<ul>
  <li><strong>LRL</strong> (Left-Right-Left)</li>
  <li><strong>RLR</strong> (Right-Left-Right)</li>
  <li><strong>LSL</strong> (Left-Straight-Left)</li>
  <li><strong>RSR</strong> (Right-Straight-Right)</li>
  <li><strong>LSR</strong> (Left-Straight-Right)</li>
  <li><strong>RSL</strong> (Right-Straight-Left)</li>
</ul>

<p>You can see three examples of the possible paths in the figure I adapted here<sup id="fnref:WikiDubin" role="doc-noteref"><a href="#fn:WikiDubin" class="footnote" rel="footnote">2</a></sup>.</p>

<h3 id="3-geometric-construction">3 Geometric Construction</h3>
<p>Dubins did indeed prove that these trajectories are the shortest paths mathematically. The geometric construction is quite intuitive and a nice toy problem to figure out on ones own but it can quickly explode into multiple pages of pen and paper calculations and diagrams which is why I am not going to go into it here. Instead, I refer to a great overview and explanation of the synthesis of Dubins paths given by David A. Anisi<sup id="fnref:DubinImplementPaper" role="doc-noteref"><a href="#fn:DubinImplementPaper" class="footnote" rel="footnote">3</a></sup>. A wonderful and in-depth guide is also given by Andy G<sup id="fnref:DubinGuide" role="doc-noteref"><a href="#fn:DubinGuide" class="footnote" rel="footnote">4</a></sup>.</p>

<h3 id="4-code">4 Code</h3>
<p>There is an abundance of implementations of Dubins paths available on the internet<sup id="fnref:code1" role="doc-noteref"><a href="#fn:code1" class="footnote" rel="footnote">5</a></sup>.</p>

<!--
What I present here is a hacked together version. First, it's useful to define a little helper to keep all the angles within the range of $$ [ 0, 2 \pi ) $$:
```python
import math as m

# normalizes an angle to the range [0, 2*pi)
def mod_to_pi(angle):
    return angle - 2.0*m.pi*m.floor(angle/2.0/m.pi)
```

Next, we actually find our Dubins paths using a planner function `general_planner()` which creates and compares the lengths of all six possible routes using `dubins_path_length()`. The data of the solution is then returned with `dubins_path()`.
```python
import nazca as nd
from nazca.interconnects import Interconnect

# Function to find the optimal Dubins path between two points
def general_planner(planner, alpha, beta, d):
    """
    Calculates the Dubins path between two points defined by their 
    angles and distance given a plan.

    Parameters:
        planner (str): Type of Dubins path. Can be one of 'LSL', 'RSR',
                        'LSR', 'RSL', 'RLR', or 'LRL'.
        alpha (float): Starting orientation angle in radians.
        beta (float): Ending orientation angle in radians.
        d (float): Distance between the two points.

    Returns:
        tuple or None: A tuple containing the Dubins path as a list of
        angles and distances, the mode of the planner, 
        and the cost of the path. 
        Returns None if the path is not feasible.
    """

    # Convert angles to sine and cosine
    sa = m.sin(alpha)
    sb = m.sin(beta)
    ca = m.cos(alpha)
    cb = m.cos(beta)
    c_ab = m.cos(alpha - beta)
    # Convert planner input to uppercase
    planner_uc = planner.upper()
    
    # Case LSL Dubins path
    if planner_uc == 'LSL':
        # Calculate intermediate values for LSL path
        tmp0 = d + sa - sb
        p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sa - sb))
        if p_squared < 0:  # Path not feasible
            return None
        tmp1 = m.atan2((cb - ca), tmp0)
        t = mod_to_pi(-alpha + tmp1)
        p = m.sqrt(p_squared)
        q = mod_to_pi(beta - tmp1)

    # Case RSR Dubins path (similar structure to LSL)
    elif planner_uc == 'RSR':
        # Calculate intermediate values for RSR path
        tmp0 = d - sa + sb
        p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sb - sa))
        if p_squared < 0:  # Path not feasible
            return None
        tmp1 = m.atan2((ca - cb), tmp0)
        t = mod_to_pi(alpha - tmp1)
        p = m.sqrt(p_squared)
        q = mod_to_pi(-beta + tmp1)

    # Case LSR Dubins path (similar structure to LSL)
    elif planner_uc == 'LSR':
        # Calculate intermediate values for LSR path
        p_squared = -2 + (d * d) + (2 * c_ab) + (2 * d * (sa + sb))
        if p_squared < 0:  # Path not feasible
            return None
        p = m.sqrt(p_squared)
        tmp2 = m.atan2((-ca - cb), (d + sa + sb)) - m.atan2(-2.0, p)
        t = mod_to_pi(-alpha + tmp2)
        q = mod_to_pi(-mod_to_pi(beta) + tmp2)

    # Case RSL Dubins path (similar structure to LSR)
    elif planner_uc == 'RSL':
        # Calculate intermediate values for RSL path
        p_squared = (d * d) - 2 + (2 * c_ab) - (2 * d * (sa + sb))
        if p_squared < 0:  # Path not feasible
            return None
        p = m.sqrt(p_squared)
        tmp2 = m.atan2((ca + cb), (d - sa - sb)) - m.atan2(2.0, p)
        t = mod_to_pi(alpha - tmp2)
        q = mod_to_pi(beta - tmp2)

    # Case RLR Dubins path (similar structure to LSL)
    elif planner_uc == 'RLR':
        # Calculate intermediate values for RLR path
        tmp_rlr = (6.0 - d * d + 2.0 * c_ab + 2.0 * d * (sa - sb)) / 8.0
        if abs(tmp_rlr) > 1.0:  # Path not feasible
            return None
        p = mod_to_pi(2 * m.pi - m.acos(tmp_rlr))
        t = mod_to_pi(alpha - m.atan2(ca - cb, d - sa + sb) + mod_to_pi(p / 2.0))
        q = mod_to_pi(alpha - beta - t + mod_to_pi(p))

    # Case LRL Dubins path (similar structure to RLR)
    elif planner_uc == 'LRL':
        # Calculate intermediate values for LRL path
        tmp_lrl = (6. - d * d + 2 * c_ab + 2 * d * (- sa + sb)) / 8.
        if abs(tmp_lrl) > 1:  # Path not feasible
            return None
        p = mod_to_pi(2 * m.pi - m.acos(tmp_lrl))
        t = mod_to_pi(-alpha - m.atan2(ca - cb, d + sa - sb) + p / 2.)
        q = mod_to_pi(mod_to_pi(beta) - alpha - t + mod_to_pi(p))

    else:
        print("The given plan ", planner, " is false.")  # Invalid planner input

    # Create the Dubins path as a list of angles and distances
    path = [t, p, q]

    # Adjust angles if planner segments are lowercase (for reverse motion)
    for i in [0, 2]:
        if planner[i].islower():
            path[i] = (2 * m.pi) - path[i]

    # Calculate the cost of the path (sum of absolute values of angles and distance)
    cost = sum(map(abs, path))

    return (path, mode, cost)

# Function to calculate the length of a Dubins path
def dubins_path_length(start, end, radius):
    # Unpack start and end configurations
    (sx, sy, syaw) = start
    (ex, ey, eyaw) = end
    
    # Convert angles to radians
    syaw = m.radians(syaw)
    eyaw = m.radians(eyaw)
    
    # Define the turning radius
    c = radius
    
    # Calculate differences in coordinates
    ex = ex - sx
    ey = ey - sy
    
    # Project end point onto start orientation
    lex = m.cos(syaw) * ex + m.sin(syaw) * ey
    ley = - m.sin(syaw) * ex + m.cos(syaw) * ey
    leyaw = eyaw - syaw
    
    # Calculate the total distance
    D = m.sqrt(lex ** 2.0 + ley ** 2.0)

    return D

# Finds the Dubins path between two points
def dubins_path(start, end, radius):

    # Calculate the length
    D = dubins_path_length(start, end, radius)
    d = D / radius

    # Define important angles
    theta = mod_to_pi(m.atan2(ley, lex))
    alpha = mod_to_pi(- theta)
    beta = mod_to_pi(leyaw - theta)

    # Iterate through all possible paths
    planners = ['LSL', 'RSR', 'LSR', 'RSL', 'RLR', 'LRL']
    bcost = float("inf")
    bt, bp, bq, bmode = None, None, None, None
    for planner in planners:

        # find the solution for the Dubins path
        solution = general_planner(planner, alpha, beta, d)

        if solution is None:
            continue

        # Collect the data from the solution
        (path, mode, cost) = solution
        (t, p, q) = path
        if bcost > cost:
            # Best cost
            bt, bp, bq, bmode = t, p, q, mode
            bcost = cost

    return (list(zip(bmode, [bt*c, bp*c, bq*c], [c] * 3)))
```
-->

<p>It doesn’t take much time to either do an implementation from scratch or adapt preexisting code. We can then wrap it all up into a single, simple to use function just like any other provided by the design library you might be using. In this case, I have been using the Nazca library<sup id="fnref:NazcaLib" role="doc-noteref"><a href="#fn:NazcaLib" class="footnote" rel="footnote">6</a></sup> which comes with several interconnects, including straights and circular arcs which are used often but very tedious and slow to work with alone. Using <code class="language-plaintext highlighter-rouge">dubin_p2p()</code>, we can simply define the start pin, the end pin, and our code will route a Dubins path between them using the straights and circular arcs provided by Nazca. Of course, this can be easily adapted to other tools like GDSFactory<sup id="fnref:GDSFactory" role="doc-noteref"><a href="#fn:GDSFactory" class="footnote" rel="footnote">7</a></sup>.</p>

<!--
```python
# Generate a Nazca cell for a given Dubins path solution
def gds_solution(xs, pin1, pin2, solution):
    """
    We draw the trajectory of a 
    given solution for a Dubins path between
    two points, here, the pins, to be rendered in .gds!
    """
    # Get the pin vectors from nazca pin1 and pin2
    start = pin1.xya()
    end = pin2.xya()

    # Change the angle for the second pin
    new_end = list(end)
    new_end[2] = new_end[2] - 180
    end = tuple(new_end)
        
    # Define the xs for the .gds file
    ic = Interconnect(xs=xs)

    # Create the cell object for the path
    with nd.Cell("dubins-path") as C:

        # Define important points
        radius = solution[0][2]
        current_position = start
        (sx, sy, syaw) = start
        (ex, ey, eyaw) = end
        ex = ex - sx
        ey = ey - sy

        # Draw the S, L, or R elements from the solution
        for (mode, length, radius) in solution:
            if mode == 'L':
                # Find the center of the circle
                center = (
                    current_position[0] 
                    + m.cos(m.radians(current_position[2] + 90)) * radius,

                    current_position[1]
                    + m.sin(m.radians(current_position[2] + 90)) * radius,
                )
                new_position = (
                    center[0] + m.cos(m.radians(current_position[2]
                    - 90 + (180 * length / (m.pi * radius)))) * radius,

                    center[1] + m.sin(m.radians(current_position[2]
                    - 90 + (180 * length / (m.pi * radius)))) * radius,

                    current_position[2] + (180 * length / (m.pi * radius))
                )
                arc_angle = (180 * length / (m.pi * radius))
                # Change this line if you want to use the function
                # in, for example, Matplotlib
                ic.bend(radius=radius, angle=arc_angle).put()
            elif mode == 'R':
                # Find the center of the circle
                center = (
                    current_position[0]
                    + m.cos(m.radians(current_position[2] - 90)) * radius,

                    current_position[1]
                    + m.sin(m.radians(current_position[2] - 90)) * radius,
                )
                new_position = (
                    center[0] + m.cos(m.radians(current_position[2]
                    + 90 - (180 * length / (m.pi * radius)))) * radius,

                    center[1] + m.sin(m.radians(current_position[2]
                    + 90 - (180 * length / (m.pi * radius)))) * radius,

                    current_position[2] - (180 * length / (m.pi * radius))
                )
                arc_angle = - (180 * length / (m.pi * radius))
                # Change this line if you want to use the function
                # in, for example, Matplotlib
                ic.bend(radius=radius, angle=arc_angle).put()
            elif mode == 'S':
                new_position = (
                    current_position[0]
                    + m.cos(m.radians(current_position[2])) * length,

                    current_position[1]
                    + m.sin(m.radians(current_position[2])) * length,

                    current_position[2],
                )
                xl = current_position[0] - new_position[0]
                yl = current_position[1] - new_position[1]
                l = m.sqrt(xl**2 + yl**2)
                # Change this line if you want to use the function
                # in, for example, Matplotlib
                ic.strt(length=l).put()
            else:
                print("Something ain't right, buddy.")
                
            current_position = new_position
    return C
-->

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#########################################################################
# Use this when designing your PIC with Nazca!
#########################################################################
</span>
<span class="c1"># Create Dubins path between two pins in Nazca
</span><span class="k">def</span> <span class="nf">dubin_p2p</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">pin2</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Finds and creates the shortest possible path between two vectors
    (pin1 and pin2) with a minimum bending radius,
    a so called </span><span class="sh">"</span><span class="s">Dubins path</span><span class="sh">"</span><span class="s">. This Dubins path is made of two
    circular bends and a straight waveguide.
    Returns a cell containing these waveguides.

    IMPORTANT
    =========
    In this version, you NEED to specify to put the path at the starting
    pin so if pin1=IO.pin[</span><span class="sh">"</span><span class="s">a0</span><span class="sh">"</span><span class="s">] you must add .put(IO.pin[</span><span class="sh">"</span><span class="s">a0</span><span class="sh">"</span><span class="s">]).
    Else, the Dubins path will be generated correctly
    but possibly at the wrong position. 
    
    PARAMETERS
    ==========
    xs:     Crosssection parameters.
    pin1:   The start pin to which the Dubins path attaches.
    pin2:   The end pin to where the Dubins path ends.
    radius: The minimum bending radius for the Dubins paths.
    width:  The width of the waveguides dubin_p2p creates.
    </span><span class="sh">"""</span>
    <span class="c1"># Get the pin vectors from pin1 and pin2
</span>    <span class="n">START</span> <span class="o">=</span> <span class="n">pin1</span><span class="p">.</span><span class="nf">xya</span><span class="p">()</span>
    <span class="n">END</span> <span class="o">=</span> <span class="n">pin2</span><span class="p">.</span><span class="nf">xya</span><span class="p">()</span>

    <span class="c1"># Change the angle for the second pin
</span>    <span class="n">new_end</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">END</span><span class="p">)</span>
    <span class="n">new_end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">180</span>
    <span class="n">END</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">new_end</span><span class="p">)</span>

    <span class="c1"># Find the Dubins path between pin1 and pin2
</span>    <span class="n">path</span> <span class="o">=</span> <span class="nf">dubins_path</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">START</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">END</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>

    <span class="c1"># Create the Dubins path with nazca using bends and straights
</span>    <span class="k">return</span> <span class="nf">gds_solution</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">pin1</span><span class="p">,</span> <span class="n">pin2</span><span class="p">,</span> <span class="n">solution</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="5-conclusion">5 Conclusion</h3>
<p>In the figure below, a comparison between a dense array of Dubins paths and arrays using Nazcas s-bends and cobra splines is made:</p>

<p><img src="/images/dubin/DubinAdvantage.PNG" alt="sleep_figure_1" /></p>

<p>As one can see, not only do other interconnects lead to over-bending of the waveguides and thus a longer path and greater losses, they are also less reliable, predictable, <strong>often break the design rules to not violate the minimum bending radius</strong> as is indeed the case here. They <strong>even intersect each other!</strong> Meanwhile, the Dubins paths behave extremely predictably. They clearly show the shortest path without unnecessary bends and they do not intersect each other which allows for much denser layouts than would be possible with the other interconnects. What I realized only after this was that there are indeed interconnects provided by Nazca which are essentially Dubins paths like <code class="language-plaintext highlighter-rouge">bend_strt_bend_p2p()</code> though not as general.</p>

<p>Also, there is a list of improvements one may make based on this. For one, the curvature of Dubins paths are not smooth which may lead to higher radiation losses. The hours of headaches I personally avoided just by using Dubins paths are insane. It is also simply much more enjoyable to use.</p>

<p>That’s my little tip for those working on photonic integrated circuit layouts. I hope it helps!</p>

<!--### BibTeX
```bibtex
@article{QWachDubin2024,
    author = {Quentin Wach},
    title = {Dubins Paths for Waveguide Routing},
    year = {2024}
```
} -->

<h3 id="references">References</h3>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:DubinPaper" role="doc-endnote">
      <p><a href="https://doi.org/10.2307/2372560">Dubins, L. E., <em>“On Curves of Minimal Length with a Constraint on Average Curvature, and with Prescribed Initial and Terminal Positions and Tangents”</em>. American Journal of Mathematics. 79 (3): 497–516, 1957</a> <a href="#fnref:DubinPaper" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:WikiDubin" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/Dubins_path">Wikipedia: Dubins Paths (Accessed: Feb 20, 2024)</a> <a href="#fnref:WikiDubin" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:DubinImplementPaper" role="doc-endnote">
      <p><a href="https://people.kth.se/~anisi/articles/foi-r-0961-se.pdf">David A. Anisi, <em>“Optimal Motion Control of a Ground Vehicle”</em>, 2003</a> <a href="#fnref:DubinImplementPaper" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:DubinGuide" role="doc-endnote">
      <p><a href="https://gieseanw.wordpress.com/2012/10/21/a-comprehensive-step-by-step-tutorial-to-computing-dubins-paths/">Andy G, <em>“A Comprehensive Step by Step Tutorial to Computing Dubins Paths”</em></a> <a href="#fnref:DubinGuide" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:code1" role="doc-endnote">
      <p><a href="https://atsushisakai.github.io/PythonRobotics/modules/path_planning/dubins_path/dubins_path.html">Atsushi Sakai, <em>“Python Robotics: Dubins Path Planning”</em>, GitHub. (Accessed: Feb 20, 2024)</a> <a href="#fnref:code1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:NazcaLib" role="doc-endnote">
      <p><a href="https://nazca-design.org/">Nazca Design: Photonic IC Design Framework</a> <a href="#fnref:NazcaLib" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:GDSFactory" role="doc-endnote">
      <p><a href="https://github.com/gdsfactory/gdsfactory">GDSFactory, GitHub</a> <a href="#fnref:GDSFactory" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>
  </div>


<!--
<h3>Enjoy Reading This Article?</h3>
<p>Here are some more articles you might like to read next:</p>





<ul>
    

        
        

        

        
    

        
        

        

        
            <li><a href="/science-engineering/2024/04/22/second-publication.html">Field-Dependent THz Transport Nonlinearities in Semiconductor Nano Structures</a></li>
            

            
        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
            <li><a href="/science-engineering/2023/01/01/first-paper.html">THz Response of Charge Carriers in Nanoparticles</a></li>
            

            
        
    

        
        

        

        
    

        
        

        

        
    

        
        

        

        
    
</ul>
-->

  <!--
  <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT 
     *  THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR 
     *  PLATFORM OR CMS.
     *  
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: 
     *  https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        // Replace PAGE_URL with your page's canonical URL variable
        this.page.url = PAGE_URL;  
        
        // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        this.page.identifier = PAGE_IDENTIFIER_2; 
    };
    */
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.src = 'https://EXAMPLE.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>
    Please enable JavaScript to view the 
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">
        comments powered by Disqus.
    </a>
</noscript>
  --><!---->


  <a class="u-url" href="/science-engineering/2024/02/15/dubins-paths-for-waveguide-routing.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">

      <div class="footer-col">
        <p></p>
      </div>
    
    </div>

    <div class="social-links">
      Hey, you scrolled all the way to the bottom! <br>

      Maybe you are interested in my more <a href="/personal" class="button">personal blog posts</a>, too.<br>
      
      Or reach out to me on social media: <br>
      <br><ul class="social-media-list"><li><a href="https://www.twitter.com/quentinwach"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">quentinwach</span></a></li></ul>
</div>

  </div>

</footer><script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        $(document).ready(function(){
            $('.tag-filter a').click(function(e){
                e.preventDefault();
                var tag = $(this).attr('href').substring(1);
                $('.post').hide();
                $('.post[data-tags~="' + tag + '"]').show();
            });
        });
    </script>


  </body>

</html>